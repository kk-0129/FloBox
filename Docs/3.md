<p><strong><a href="https://github.com/kk-0129/Flo">FLO - Distributed Hierarchical Dataflow</a></strong></p>
<p>Swift package: <strong><a href="../README.md">FloBox</a></strong></p>
<h1>Remote Device Servers</h1>
<p>This section defines structs and classes for creating, and communicating with remote devices. In FLO, a 'device' is a small publish-subscribe server hosting multiple black-box processes. Each of these boxes can be incorporated into a dataflow graph as a 'proxy' box - where:</p>
<ul>
<li>data flowing into a proxy box (at its inputs) is transparently transmitted over the network to the corresponding box hosted on the remote device,</li>
<li>data generated by the remotely hosted process is transparently sent back over the network and made available at local proxy box's outputs.</li>
</ul>
<p>Remote devices can be implemented in any programming language, the only requirement is
that they conform to the FLO <a href="4.md">Network Protocol</a>. At present there are implementations in:</p>
<ul>
<li><a href="https://github.com/kk-0129/FloBox/tree/main/Sources/FloBox/Device">Swift</a></li>
<li><a href="https://github.com/kk-0129/FloDev/tree/main/Julia">Julia</a></li>
<li><a href="https://github.com/kk-0129/FloDev/tree/main/Python2">Python</a></li>
</ul>
<p>The subsections below describe the Swift implementation:</p>
<ol>
<li>the protocol requirements for wrapping remote processes as boxes,</li>
<li>network endpoints and their addresses,</li>
<li>the messages exchanged between proxies and remote devices,</li>
<li>and finally, the Device class itself.</li>
</ol>
<h2>1. Boxes</h2>
<p>In order to be published by a device, a process must conform to the <code>Device.Box</code> protocol (in <a href="../Sources/FloBox/Device/Device.swift">Device.swift</a>), which has 3 main features:</p>
<ul>
<li>A <code>Skin</code> (in <a href="../Sources/FloBox/Skin.swift">Skin.swift</a>), which defines the name, inputs and outputs of the process/box.</li>
<li>A <code>publish</code> method, invoked by the device whenever it receives input data for the box:
<ul>
<li>the incoming data are encoded in a <code>[Ports.ID:Event]</code> dictionary  (see <a href="../Sources/FloBox/Ports.swift">Ports.swift</a> &amp; <a href="../Sources/FloBox/Events/Event.swift">Event.swift</a>) whose keys are the names of box inputs.</li>
</ul>
</li>
<li>A <code>callback</code> variable, whose value is a function set by the device, which must be invoked by the process itself whenever one or more of its outputs changes value:
<ul>
<li>the outgoing data are encoded in a <code>[Ports.ID:Event]</code> dictionary  (see <a href="../Sources/FloBox/Ports.swift">Ports.swift</a> &amp; <a href="../Sources/FloBox/Events/Event.swift">Event.swift</a>) dictionary whose keys are the names of box outputs.</li>
</ul>
</li>
</ul>
<p>The code below shows a minimal implementation of a <code>Device.Box</code>:</p>
<ul>
<li>The <code>skin</code> variable names the box &quot;Echo&quot; and gives it a BOOL valued input called &quot;in&quot;, and a BOOL valued output called &quot;out&quot;.</li>
<li>The <code>publish</code> method looks to see if its inputs argument has an <code>Event</code> entry for the key &quot;in&quot;, and if so invokes the <code>callback</code> function to pass this <code>Event</code> on to the output called &quot;out&quot;. The device then transmits the event over the network to any registered proxies.</li>
</ul>
<pre><code>public class Echo : Device.Box{

    // the sking defines the box's name, inputs and outputs
    let skin = Skin(
        "Echo", // name
        ["in":BOOL()], // inputs
        ["out":BOOL()] // outputs
    )

    // this variable is set by the device
    var callback:(([Ports.ID:Event])->())?

    // this function is called by the device when data is sent to the box inputs
    func publish(_ inputs:[Ports.ID:Event]){
        if let event = inputs["in"]{
            callback(["out":event]) // tells the device to send the event from output "out"
        }
    }
}
</code></pre>
<h2>2. Endpoints</h2>
<p>In order to communicate, remote devices and their local proxies both need to be addressable
network entities. Flo makes no assumptions about how network communications are realised, but
instead uses an abstract <code>EP</code> protocol to capture a generic network &quot;endpoint&quot;. Every <code>EP</code> has a network address captured generically by an <code>EP.Address</code> protocol (in <a href="../Sources/FloBox/Device/EP.swift">EP.swift</a>). FLO provides default implementations of both these protocols:</p>
<ul>
<li><code>IPv4</code> (in <a href="../Sources/FloBox/Device/Addresses/IPv4.swift">IPv4.swift</a>) for <a href="https://en.wikipedia.org/wiki/IPv4">IPv4</a> addresses</li>
<li><code>UDP.EP</code> (in <a href="../Sources/FloBox/Device/UDP.swift">UDP.swift</a>) for endpoints capable of sending/receiving <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a> (datagram) communications</li>
</ul>
<p>An example using the <code>UDP.EP</code> class to create and launch a new <code>Device</code> is given in
Section 4 below.</p>
<h2>3. Messages</h2>
<p>The messages sent to/from FLO devices are encapsulated by a <code>Message</code> struct (defined in <a href="../Sources/FloBox/Device/Msg.swift">Msg.swift</a>), with the following fields:</p>
<ul>
<li>a <code>token</code> (type <code>UInt64</code>, aliased as <code>Message.Token</code>) that uniquely identifies the &quot;conversation&quot; in which the message occurs.</li>
<li>a <code>payload</code> (type <code>Payload</code>, below) which carries the meaningful content of a message,</li>
<li>a <code>Boolean</code> flag specifying whether the message is a request or reply.</li>
</ul>
<p>The payload of a message is a parametrised <code>case</code> of a <code>Payload</code> enum (in <a href="../Sources/FloBox/Device/Msg.swift">Msg.swift</a>). The semantics of payloads are fully defined in <a href="4.md">Network Protocol</a>, but in brief:</p>
<ul>
<li>a <code>HANDSHAKE</code> case is used to establish the authenticity and authorisation of endpoints,</li>
<li><code>PING</code> and <code>PING_UPDATE</code> cases are periodic messages used to check device availability, and notify a client of any changes to the device's published boxes,</li>
<li><code>SUBSCRIBE</code> and <code>END_SUBSCRIBE</code> cases allow clients to start/stop receiving data from remote box outputs,</li>
<li>a <code>PUBLISH</code> case allows clients to send data to remote box inputs.</li>
</ul>
<h2>4. Devices</h2>
<p>We can now bring all the elements defined in the sections above together to create a FLO device.
As stated above, devices can be implemented in any programming language so long as they conform to the <a href="4.md">Network Protocol</a>. At present FLO provides device implementations in <a href="https://github.com/kk-0129/FloBox/tree/main/Sources/FloBox/Device">Swift</a>,
<a href="https://github.com/kk-0129/FloDev/tree/main/Julia">Julia</a> and <a href="https://github.com/kk-0129/FloDev/tree/main/Python2">Python</a>.</p>
<p>The <a href="https://github.com/kk-0129/FloBox/tree/main/Sources/FloBox/Device">Swift</a> implementation comprises:</p>
<ul>
<li>a <code>Name</code> which is descriptive only (and does not need to be universally unique),</li>
<li>the hosted collection of black boxes, i.e. instances of the <code>Device.Box</code> protocol (in [Device.swift](../Sources/FloBox/Device/Device.swift, and described in Section 1 above),</li>
<li>a network endpoint - i.e an instance of the EP protocol (in <a href="../Sources/FloBox/Device/EP.swift">EP.swift</a>, and described in Section 2 above), which can send and listen for incoming messages (Section 3 above) at a specific network address.</li>
</ul>
<p>The following code illustrates how to instantiate a device in <a href="https://github.com/kk-0129/FloBox/tree/main/Sources/FloBox/Device">Swift</a> to host the <code>Echo</code> box from Section 1 above:</p>
<pre><code>var device: Device?
if let addr = IPv4.local(port:9999){                 // IPv4 address
    do{
        device = Device(
                   "My Device Name",                 // name
                   endpoint: try UDP.EP(ipa:addr),   // network endpoint
                   boxs: [ Echo() ]                  // list of hosted boxes
                 )
    }catch e{
        // handle the error
    }
}
</code></pre>
